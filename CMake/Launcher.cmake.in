set(ENVVAR "@ENVVAR@")
set(NAME "@NAME@")
set(CUSTOMIZATIONS "@CUSTOMIZATIONS@")
if(WIN32)
  set(CMD $ENV{COMSPEC} /c)
  set(PATHSEP ";")
  set(STDIO)
elseif(UNIX)
  set(CMD)
  set(PATHSEP ":")
  set(STDIO INPUT_FILE "/dev/stdin" OUTPUT_FILE "/dev/stdout" ERROR_FILE "/dev/stderr")
else()
  message(FATAL_ERROR "Platform is not supported.")
endif()


# setup environment variables
foreach(X ${ENVVAR})
  string(FIND ${X} "+=" ENVVAR_APPEND)
  string(FIND ${X} "=+" ENVVAR_PREPEND)
  string(FIND ${X} "==" ENVVAR_SET)
  if(NOT ENVVAR_APPEND EQUAL -1)
    string(REPLACE "+=" ";" X "${X}")
  elseif(NOT ENVVAR_PREPEND EQUAL -1)
    string(REPLACE "=+" ";" X "${X}")
  elseif(NOT ENVVAR_SET EQUAL -1)
    string(REPLACE "==" ";" X "${X}")
  endif()
  list(GET X 0 KEY)
  list(GET X 1 VALUE)
  if(WIN32 AND KEY MATCHES "^MATLABPATH$")
    set(KEY "MATLABPATH_FALLBACK")
  endif()
  if(NOT DEFINED ENV{CMakeAll_ORIGINAL_${KEY}})
    if(NOT DEFINED ENV{${KEY}})
      set(ENV{CMakeAll_ORIGINAL_${KEY}} "\"\"")
    else()
      set(ENV{CMakeAll_ORIGINAL_${KEY}} "$ENV{${KEY}}")
    endif()
  endif()
  file(TO_NATIVE_PATH ${VALUE} VALUE)
  if(NOT ENVVAR_APPEND EQUAL -1)
    set(ENV{${KEY}} "$ENV{${KEY}}${PATHSEP}${VALUE}")
  elseif(NOT ENVVAR_PREPEND EQUAL -1)
    set(ENV{${KEY}} "${VALUE}${PATHSEP}$ENV{${KEY}}")
  elseif(NOT ENVVAR_SET EQUAL -1)
    set(ENV{${KEY}} "${VALUE}")
  endif()
endforeach()


# initialize ARGV and HELP
set(ARGV)
foreach(I RANGE 3 ${CMAKE_ARGC})
  list(APPEND ARGV ${CMAKE_ARGV${I}})
endforeach()
set(HELP
  "\n A cross-platform launcher that configures environment variables and executes\n"
  " the provided command within the current shell.\n\n"
  " Usage: cmake -P ${NAME}.cmake <command>\n"
  " Command aliases:\n")


# include customizations
if(CUSTOMIZATIONS)
  include(${CUSTOMIZATIONS})
endif()


# command alias: Terminal
list(APPEND HELP "   Terminal - Default shell with a configured environment.\n")
if(ARGV MATCHES "^Terminal$")
  if(WIN32)
    set(ARGV $ENV{COMSPEC})
  elseif(UNIX)
    set(ARGV $ENV{SHELL})
  else()
    message(FATAL_ERROR "Platform is not supported.")
  endif()
  message("Launching terminal...")
endif()


# command alias: Patch
list(APPEND HELP "   Patch <source> [target] - Create and dry-run a patch of a source directory under svn/git.\n")
if(ARGV MATCHES "^Patch")
  list(GET ARGV 1 SOURCE_DIR)
  list(GET ARGV 2 PATCH_FILE)
  get_filename_component(SOURCE_DIR ${SOURCE_DIR} ABSOLUTE)
  get_filename_component(PATCH_FILE ${PATCH_FILE} ABSOLUTE)
  if(IS_DIRECTORY "${SOURCE_DIR}/.git")
    message("Detected '${SOURCE_DIR}' as Git repository")
    find_program(GIT_EXECUTABLE git)
    mark_as_advanced(GIT_EXECUTABLE)
    if(NOT GIT_EXECUTABLE)
      message(FATAL_ERROR "git is required")
    endif()
    execute_process(COMMAND ${GIT_EXECUTABLE} diff --ignore-space-at-eol OUTPUT_FILE ${PATCH_FILE} WORKING_DIRECTORY ${SOURCE_DIR})
    execute_process(COMMAND ${GIT_EXECUTABLE} apply --check --reverse ${PATCH_FILE} WORKING_DIRECTORY ${SOURCE_DIR})
  elseif(IS_DIRECTORY "${SOURCE_DIR}/.hg")
    message("Detected '${SOURCE_DIR}' as Mercurial repository")
    find_program(HG_EXECUTABLE hg)
    mark_as_advanced(HG_EXECUTABLE)
    if(NOT HG_EXECUTABLE)
      message(FATAL_ERROR "hg is required")
    endif()
    find_program(PATCH_EXECUTABLE patch)
    mark_as_advanced(PATCH_EXECUTABLE)
    if(NOT PATCH_EXECUTABLE)
      message(FATAL_ERROR "patch is required")
    endif()
    execute_process(COMMAND ${HG_EXECUTABLE} export OUTPUT_FILE ${PATCH_FILE} WORKING_DIRECTORY ${SOURCE_DIR})
    execute_process(COMMAND ${PATCH_EXECUTABLE} --dry-run --reverse --strip=1 --input=${PATCH_FILE} WORKING_DIRECTORY ${SOURCE_DIR})
  elseif(IS_DIRECTORY "${SOURCE_DIR}/.svn")
    message("Detected '${SOURCE_DIR}' as Subversion repository")
    find_program(SVN_EXECUTABLE svn)
    mark_as_advanced(SVN_EXECUTABLE)
    if(NOT SVN_EXECUTABLE)
      message(FATAL_ERROR "svn is required")
    endif()
    execute_process(COMMAND ${SVN_EXECUTABLE} diff --extensions "--ignore-eol-style" OUTPUT_FILE ${PATCH_FILE} WORKING_DIRECTORY ${SOURCE_DIR})
    execute_process(COMMAND ${SVN_EXECUTABLE} patch --dry-run --reverse-diff ${PATCH_FILE} WORKING_DIRECTORY ${SOURCE_DIR})
  else()
    message(WARNING "Skipping diff, '${SOURCE_DIR}' is not under git/hg/svn version control")
    find_program(PATCH_EXECUTABLE patch)
    mark_as_advanced(PATCH_EXECUTABLE)
    if(NOT PATCH_EXECUTABLE)
      message(FATAL_ERROR "patch is required")
    endif()
    execute_process(COMMAND ${PATCH_EXECUTABLE} --dry-run --reverse --input=${PATCH_FILE} WORKING_DIRECTORY ${SOURCE_DIR})
  endif()
  set(ARGV ${CMAKE_COMMAND} -E echo "Updated '${PATCH_FILE}'")
endif()


# execute commands
if(ARGV)
  execute_process(COMMAND ${ARGV} RESULT_VARIABLE RESULT ${STDIO})
  if(RESULT STREQUAL "No such file or directory")
    message("${RESULT}")
  endif()
else()
  message(${HELP})
endif()
